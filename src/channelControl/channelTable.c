/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <string.h>
#include <glib-2.0/glib.h>
#include <glib-unix.h>
#include <gstreamer-1.0/gst/sdp/gstsdpmessage.h>
#include <gstreamer-1.0/gst/gst.h>
#include <arpa/inet.h>
#include "../../include/mibParameters.h"
#include "../../include/conf/mib-conf.h"
#include "../../include/deviceInfo/ethernetIfTable.h"
#include "../../include/multicast.h"
#include "../../include/videoFormatInfo/videoFormatTable.h"
#include "../../include/handler.h"
#include "../../include/channelControl/channelTable.h"
#include "../../include/announcement/sap.h"
#include "../../include/announcement/sdp.h"
#include "../../include/streaming/stream_registration.h"
#include "../../include/streaming/pipeline.h"
#include "../../include/streaming/stream.h"
#include "../../include/streaming/roi.h"



/**
 * \brief Initializes the channelTable module
 */
void
init_channelTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_channelTable();
}


/**
 * \brief Initialize the channelTable table by defining its contents and how it's structured
 */
void
initialize_table_channelTable(void)
{
    const oid channelTable_oid[] = {1,3,6,1,4,1,35990,3,1,3,3};
    const size_t channelTable_oid_len   = OID_LENGTH(channelTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("channelTable:init", "initializing table channelTable"));

    reg = netsnmp_create_handler_registration(
              "channelTable",     channelTable_handler,
              channelTable_oid, channelTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: channelIndex */
                           0 /* to terminate the list of parameters*/);
    table_info->min_column = COLUMN_CHANNELTYPE;
    table_info->max_column = COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS;

    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = channelTable_get_first_data_point;
    iinfo->get_next_data_point  = channelTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;

    netsnmp_register_table_iterator( reg, iinfo );
	/* check if the device is a serviceProvider or a ServiceUser
	 * If it is a serviceUser or both, then create an empty entry
	 */
	long default_receive_IP = 0; /* a variable to retreive the default receive IP entered by the user in configuration file */
	char *ip; /* the receive IP in a string form */

	if( deviceInfo.parameters[num_DeviceType]._value.int_val != device_SP ){
		for(int i=0; i<channelNumber._value.int_val; i++){
			/* get the default IP address to use for defaultStartUp mode if it has been entered in the configuration file */
			ip = get_default_IP_from_conf(i+1);
			if ( ip )
				default_receive_IP 	= inet_addr(get_default_IP_from_conf(i+1));
			channelTable_create_empty_entry(i+1, serviceUser,"" ,0, default_receive_IP,  NULL ); /* create a channel with "0" as videoFormatIndex */
		}
	}
}

/**
 * \brief adds an entry into channelTable_SU
 * \param new_entry the entry to add into the table
 */
static void add_in_channel_SU(struct channelTable_entry *new_entry){
		new_entry->next_SU = channelTable_SU_head;
		channelTable_SU_head = new_entry;
}

/**
 * \brief pops an entry  channelTable_SU
 * \param new_entry the entry to add into the table
 * \param entry_index the index of the entry to pop
 */
static void pop_from_channel_SU( struct channelTable_entry *table_entry){
	struct channelTable_entry *iterator = channelTable_SU_head;
	/* check if we want to pop the head */
	if ( table_entry == channelTable_SU_head ){
		channelTable_SU_head = NULL; /* then pop head, set it to NULL */
		return;
	}
	while (table_entry!= NULL && iterator->next_SU != table_entry)
		iterator = iterator->next_SU;
	/* the entry to pop is next_SU */
	if( iterator->next_SU != NULL)
		iterator->next_SU =	iterator->next_SU->next_SU;
	else /* it means we are trying to pop the last element of the table */
		iterator->next_SU = NULL;
	/* we don't free the memory because the entry remains in the classic channelTable */
}


/**
 * \brief create a new row in the (unsorted) table
 * \param all teh parameters' values we need to initiate the channelTable_entry
 * \param stream_datas the stream_data (pipeline/bus) associated to this channel entry
 * \return the newly created entry that has been added in the channelTable
 */
struct channelTable_entry *
	channelTable_createEntry(
    	        				long 		channelIndex,
								long  		channelType,
						    	char* 		channelUserDesc,
    							long 		channelStatus,
							    long 		channelVideoFormatIndex,
							    char*  		channelVideoFormat,
							    char* 		channelVideoSampling,
							    long 		channelVideoBitDepth,
							    long 		channelFps,
							    char* 		channelColorimetry,
							    long 		channelInterlaced,
							    long 		channelCompressionFactor,
							    long 		channelCompressionRate,
    							long 		channelHorzRes,
    							long 		channelVertRes,
							    long 		channelRoiOriginTop,
							    long 		channelRoiOriginLeft,
							    long 		channelRoiExtentBottom,
							    long 		channelRoiExtentRight,
							    long 		channelRtpPt,
							    in_addr_t 	channelReceiveIpAddress,
							    long 		channelInterPacketDelay,
							    long 		channelSapMessageInterval,
							    long 		channelDefaultVideoFormatIndex,
							    in_addr_t 	channelDefaultReceiveIpAddress,
								gpointer 	stream_datas
                			) {
    struct channelTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct channelTable_entry);
    if (!entry)
        return NULL;

    entry->channelIndex 					= channelIndex;
	entry->channelType 						= channelType;
 	entry->channelUserDesc 					= strdup(channelUserDesc);
	entry->channelUserDesc_len 				= MIN(strlen(channelUserDesc), DisplayString64);
	entry->channelStatus 					= channelStatus;
	entry->channelVideoFormatIndex 			= channelVideoFormatIndex;
	entry->channelVideoFormat 	 			= strdup(channelVideoFormat);
	entry->channelVideoFormat_len			= MIN(strlen(channelVideoFormat), DisplayString16);
	entry->channelVideoSampling 			= strdup(channelVideoSampling);
	entry->channelVideoSampling_len			= MIN(strlen(channelVideoSampling), DisplayString16);
	entry->channelVideoBitDepth 			= channelVideoBitDepth;
	entry->channelFps 						= channelFps;
	entry->channelColorimetry 				= strdup(channelColorimetry);
	entry->channelColorimetry_len 			= MIN(strlen(channelColorimetry), DisplayString16);
	entry->channelInterlaced 				= channelInterlaced;
	entry->channelCompressionFactor 		= channelCompressionFactor;
	entry->channelCompressionRate 			= channelCompressionRate;
	entry->channelHorzRes 					= channelHorzRes;
	entry->channelVertRes 					= channelVertRes;
	entry->channelRoiOriginTop 				= channelRoiOriginTop;
	entry->channelRoiOriginLeft 			= channelRoiOriginLeft;
	entry->channelRoiExtentBottom 			= channelRoiExtentBottom;
	entry->channelRoiExtentRight 			= channelRoiExtentRight;
	entry->channelRtpPt 					= channelRtpPt;
	entry->channelReceiveIpAddress 			= channelReceiveIpAddress;
	entry->channelInterPacketDelay 			= channelInterPacketDelay;
	entry->channelSapMessageInterval 		= channelSapMessageInterval;
	entry->channelDefaultVideoFormatIndex 	= channelDefaultVideoFormatIndex;
	entry->channelDefaultReceiveIpAddress 	= channelDefaultReceiveIpAddress;

	/* register stream data */
	entry->stream_datas 					= stream_datas;

	/* allocate memory for sap_data */
	sap_data 	*sap_datas = (sap_data*) malloc(sizeof(sap_data));
	entry->sap_datas = sap_datas;

	entry->valid 							= 1;
	entry->next 							= channelTable_head;
	channelTable_head 						= entry;
    return entry;
}

/**
 * \brief Create an empty entry a SU entry or a SP entry
 */
struct channelTable_entry *	channelTable_create_empty_entry(int index,long channel_type, char *channelUserDesc , long videoFormatNumber ,  long default_IP_address, gpointer stream_datas ){

	struct channelTable_entry *ServiceUser_entry =
			channelTable_createEntry(
    	      				index, /* Appen one channel to the list, its index is just the number of channel incremented by one */
							channel_type,
					    	channelUserDesc,
    						channelStop,
						    videoFormatNumber,
						    "",
						    "",
						    0,
						    0,
						    "",
						    0,
						    0,
						    0,
    						0,
    						0,
						    0,
						    0,
							0,
						   	0,
						   	0,
						   	0,
						   	0,
						   	default_SAP_interval,
						   	0,
						   	default_IP_address,
						 	NULL
               			);

	return ServiceUser_entry;
}

/**
 * \brief fill an entry in the ChannelTable
 * \param entry the entry in channelTable to update
 * \param  videoFormatIndex the VF that will be used to get the parameters
 * \return TRUE if we succeed to update the parameters
 */
gboolean channelTable_fill_entry(struct channelTable_entry * entry, struct videoFormatTable_entry *videoFormatentry){

        /* fill ChannelTable_entry parameter with the ones from videoFormatentry */
		entry->channelVideoFormat 							= strdup(videoFormatentry->videoFormatBase);
		entry->channelVideoFormat_len 						= MIN(strlen(videoFormatentry->videoFormatBase), 		DisplayString16);
		entry->channelVideoSampling 						= strdup(videoFormatentry->videoFormatSampling);
		entry->channelVideoSampling_len 					= MIN(strlen(videoFormatentry->videoFormatSampling), 	DisplayString16);
		entry->channelVideoBitDepth 						= videoFormatentry->videoFormatBitDepth;
		entry->channelFps 									= videoFormatentry->videoFormatFps;
		entry->channelColorimetry 							= strdup(videoFormatentry->videoFormatColorimetry);
		entry->channelColorimetry_len 						= MIN(strlen(videoFormatentry->videoFormatColorimetry), DisplayString16);
		entry->channelInterlaced 							= videoFormatentry->videoFormatInterlaced;
		entry->channelCompressionFactor 					= videoFormatentry->videoFormatCompressionFactor;
		entry->channelCompressionRate 						= videoFormatentry->videoFormatCompressionRate;
		entry->channelHorzRes 								= videoFormatentry->videoFormatMaxHorzRes;
		entry->channelVertRes 								= videoFormatentry->videoFormatMaxVertRes;
		entry->channelRtpPt 								= videoFormatentry->videoFormatRtpPt;

		return TRUE;
}

/**
 * \brief replace the content of the videoFormat_entry with the content of the channelTable_entry
 * \param entry the entry in channelTable to update
 * \param  videoFormatIndex the VF that will be used to get the parameters
 * \return TRUE if we succeed to update the parameters
 */
gboolean update_videoFormat_entry_roi_from_channelTable_entry ( struct videoFormatTable_entry *videoFormat_entry , struct channelTable_entry *channel_entry )
{

	/* only the ROI parameters of the videoFormat_entry can be modifies, otherwise nothing could */
	if ( channel_entry->channelType == serviceUser ){
		videoFormat_entry->videoFormatMaxHorzRes 		= channel_entry->sdp_width; 				/* Set Res from SDP, usefull to vivoecrop */
		videoFormat_entry->videoFormatMaxVertRes 		= channel_entry->sdp_height; 				/* Set Res from SDP, usefull to vivoecrop */
	}
	videoFormat_entry->videoFormatRoiHorzRes 		= channel_entry->channelHorzRes ;
	videoFormat_entry->videoFormatRoiVertRes 		= channel_entry->channelVertRes ;
	videoFormat_entry->videoFormatRoiOriginTop 		= channel_entry->channelRoiOriginTop ;
	videoFormat_entry->videoFormatRoiOriginLeft 	= channel_entry->channelRoiOriginLeft ;
	videoFormat_entry->videoFormatRoiExtentBottom 	= channel_entry->channelRoiExtentBottom ;
	videoFormat_entry->videoFormatRoiExtentRight 	= channel_entry->channelRoiExtentRight ;

	/* return TRUE */
	return TRUE;

}

#define WIDTH_SDP 			"width"

#define HEIGTH_SDP 			"height"

#define ROITOP_SDP 			"roitop"

#define ROILEFT_SDP 		"roileft"

#define ROIBOTTOM_SDP "roiextentbottom"

#define ROIRIGTH_SDP 	"roiextentright"

/**
 * \brief update the content of the channelTable_entry with the new caps receive
 * \param entry the entry in channelTable to update
 * \param  videoFormatIndex the VF that will be used to get the parameters
 * \return TRUE if we succeed to update the parameters
 */
void update_channelTable_entry_roi_from_caps ( struct channelTable_entry *channel_entry , GstCaps *caps )
{

	const gchar *temp;

	g_debug("update_channelTable_entry_roi_from_caps()");

	/* only the ROI parameters of the videoFormat_entry can be modifies, otherwise nothing could */
	GstStructure *caps_str = gst_caps_get_structure	(caps , 0) ;

	if ( gst_structure_has_field(caps_str , WIDTH_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "width"));
		if ( temp )
			channel_entry->channelHorzRes = (long) strtol( temp , NULL, 10) ;
	}
	if ( gst_structure_has_field(caps_str , HEIGTH_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "height")) ;
		if ( temp )
			channel_entry->channelVertRes = (long) strtol( temp , NULL, 10) ;
	}

	if ( gst_structure_has_field(caps_str , ROITOP_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "roitop")) ;
		if ( temp )
			channel_entry->channelRoiOriginTop = (long) strtol( temp , NULL, 10) ;
	}

	if ( gst_structure_has_field(caps_str , ROILEFT_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "roileft")) ;
		if ( temp )
			channel_entry->channelRoiOriginLeft = (long) strtol( temp , NULL, 10) ;
	}

	if ( gst_structure_has_field(caps_str , ROIBOTTOM_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "roibottom")) ;
		if ( temp )
			channel_entry->channelRoiExtentBottom = (long) strtol( temp , NULL, 10) ;
	}

	if ( gst_structure_has_field(caps_str , ROIRIGTH_SDP ) ){
		temp = g_value_get_string( gst_structure_get_value(caps_str , "roiright")) ;
		if ( temp )
			channel_entry->channelRoiExtentRight = (long) strtol( temp , NULL, 10) ;
	}

	/*
	 * This function is only used on the Service Users side, so there is no need to update the corresponding
	 * videoFormat_entry (as it does not exist anyway )
	 */

}

/**
 * \brief update an entry in the ChannelTable when changing its videoFormat
 * \param entry the entry in channelTable to update
 * \param videoFormatIndex the new videoFormatIndex to use for this channel
 * \return TRUE if we succeed to update the parameters
 */
gboolean channelTable_updateEntry(struct channelTable_entry * entry ){


	   /* get the correspondant entry in the table of VideoFormat */
       struct videoFormatTable_entry *videoFormatEntry         = videoFormatTable_getEntry(  entry->channelVideoFormatIndex );
       if ( videoFormatEntry == NULL)
               return FALSE;

	   /* get the correspondant entry in the table of VideoFormat */
       struct videoFormatTable_entry *videoFormatEntry_old         = videoFormatTable_getEntry( entry->old_channelVideoFormatIndex );
       if ( videoFormatEntry_old == NULL)
               return FALSE;

	   if ( videoFormatEntry->videoFormatStatus == enable || videoFormatEntry_old->videoFormatStatus == enable )
		   return FALSE;

	   channelTable_fill_entry( entry, videoFormatEntry );

	   /* update the stream data */
		entry->stream_datas 								= videoFormatEntry->stream_datas;

		stream_data *data 									= entry->stream_datas;
		/* transform IP from long to char * */
		set_udpsink_param(data->udp_elem, entry->channelIndex);

		return TRUE;

}

#if 0
/**
 * \brief update an entry in the ChannelTable when changing its videoFormat
 * \param entry the entry in channelTable to update
 * \param videoFormatIndex the new videoFormatIndex to use for this channel
 * \return TRUE if we succeed to update the parameters
 */
gboolean channelTable_updateEntry(struct channelTable_entry * entry, int videoFormatNumberIndex){

       /* get the correspondante entry in the table of VideoFormat */
       struct videoFormatTable_entry *videoFormatentry         = videoFormatTable_getEntry( videoFormatNumberIndex );
       if ( videoFormatentry == NULL)
               return FALSE;

	   channelTable_fill_entry( entry, videoFormatentry );

	   /* update the stream data */
		entry->stream_datas 								= videoFormatentry->stream_datas;

		/* check if streaming was in play state */
		struct videoFormatTable_entry * stream_entry 		= videoFormatTable_getEntry(videoFormatNumberIndex);

		if( stream_entry->videoFormatStatus == enable )
			stop_streaming(entry->stream_datas , entry->channelVideoFormatIndex );

		stream_data *data 									= entry->stream_datas;
		/* transform IP from long to char * */
		set_udpsink_param(data->udp_elem, entry->channelIndex);

		return TRUE;
}
#endif

/**
 * \brief retrieve the entry in the channelTable corresponding to the index given in parameter
 * \param index the index of the entry we want
 * \return channelTable_entry*  a pointer on that entry
 */
struct channelTable_entry * channelTable_getEntry(int index){
	struct channelTable_entry *iterator = channelTable_head;
	while(iterator->channelIndex != index){
		if(iterator->next != NULL)
			iterator = iterator->next;
		else
			return NULL;
	}
	return iterator;
}

/**
 * \brief retrieve the entry in the channelTable corresponding to the VF index given in parameter
 * \param index the index of the entry we want
 * \return channelTable_entry*  a pointer on that entry
 */
struct channelTable_entry * channelTable_get_from_VF_index(int index){
	struct channelTable_entry *iterator = channelTable_head;
	while(iterator->channelVideoFormatIndex	!= index){
		if(iterator->next != NULL)
			iterator = iterator->next;
		else
			return NULL;
	}
	return iterator;
}

void channelTable_delete(){
	struct channelTable_entry *iterator = channelTable_head;
	struct channelTable_entry *temp;
	while(iterator != NULL){
		temp = iterator;
		iterator = iterator->next;
		free(temp);
	}
}

#if  ALLOW_REMOVING_ROW
/* remove a row from the table */
void
channelTable_removeEntry( struct channelTable_entry *entry ) {
    struct channelTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = channelTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        channelTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}
#endif //if ALLOW_REMOVING_ROW


void
channelTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct channelTable_entry *this, *that;

    for ( this = channelTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    channelTable_head = NULL;
}

/**
 * \brief get the first data in tabel
 */
netsnmp_variable_list *
channelTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = channelTable_head;
    return channelTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

/**
 * \brief get the next data in table
 */
netsnmp_variable_list *
channelTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct channelTable_entry *entry = (struct channelTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->channelIndex );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/**
 * \brief handles the call of function according to the new channeltStatus value received from SNMP request
 * \param table_entry the table entry on which the request applies
 * \return TRUE on success, FALSE on failure
 */
gboolean channelSatus_requests_handler( struct channelTable_entry * table_entry ){
	/* the behaviour will be different wether the device is a ServiceProvider or a ServiceUser */
	switch( table_entry->channelType ){
		case videoChannel: /* case ServiceProvider */
		case roi:
			if ( table_entry->channelStatus 		== channelStart){
				prepare_socket( table_entry );
				send_announcement ( table_entry ); /* send the announcement once, so it is received shorlty be all Service Users */
				g_timeout_add(table_entry->channelSapMessageInterval,send_announcement, table_entry );
				if ( !start_streaming( table_entry->stream_datas, table_entry->channelVideoFormatIndex)){
					g_warning( "failed to start streaming");
					return FALSE;
				}
				return TRUE;
			}
			else if ( table_entry->channelStatus 	== channelStop)
				return stop_streaming( table_entry->stream_datas, table_entry->channelVideoFormatIndex );
			break;
		case serviceUser:
			if ( table_entry->channelStatus 		== channelStart){
				add_in_channel_SU(table_entry);
			}
			else if ( table_entry->channelStatus 	== channelStop){
				delete_steaming_data(table_entry);
			 	pop_from_channel_SU(table_entry);
			}
			return TRUE;
			break;
		default:
			/* this is a really really bad error, we should never get there */
			g_warning("Unknown channel Type");
			return FALSE;
			break;
	}
	return FALSE;
}

/**
 * \brief handles the call of function according
 * \param table_entry the table entry on which the request applies
 * \return TRUE on success, FALSE on failure
 */
static gboolean roi_requests_handler( struct channelTable_entry * table_entry , struct videoFormatTable_entry *videoFormat_entry ){

	struct videoFormatTable_entry *video_stream_info = NULL ;

	g_debug("roi_requests_handler()");

	/*
	 * If we are a Service User, we are going to build a "fake" videoFormat entry
	 */
	if ( table_entry->channelType == serviceUser )
		video_stream_info = SNMP_MALLOC_TYPEDEF(struct videoFormatTable_entry);
	else
		video_stream_info = videoFormat_entry; /* otherwise use the entry given into parameters */

	/* update a copy of the videoFormat associated videoFormat in consequences */
	 update_videoFormat_entry_roi_from_channelTable_entry ( video_stream_info , table_entry );

	/*
	 * Now update pipeline
	 * If an error occurs, we just reset the old roi parameters' values of channel and video_stream_info
	 */
	if ( ! update_pipeline_on_roi_changes( table_entry->stream_datas ,  table_entry , video_stream_info )  && ! update_camera_ctl_on_roi_changes ( table_entry ) )
		return FALSE;
	else{
		/* If this is a SP we need to re-send a new SDP file, so we call the channelStatus request handler */
		if ( table_entry->channelType != serviceUser )
			return channelSatus_requests_handler(  table_entry ) ; /* this is to build a new SDP file and send it right away */
		/* if not just return TRUE */
		return TRUE;
	}

}


/**
 * \brief handles requests for the channelTable table
 * \param handler the specific handler for this item
 * \param reqinfo the SNMP request
 * \param reuests the resuest information
 * \param mib_parameter the parameter of the MIB
 * \return SNMP_ERR_NOERROR or approriate code error
 */
int
channelTable_handler(
    netsnmp_mib_handler             *handler,
    netsnmp_handler_registration    *reginfo,
    netsnmp_agent_request_info      *reqinfo,
    netsnmp_request_info            *requests) {

    netsnmp_request_info       		*request;
    netsnmp_table_request_info 		*table_info;
    struct channelTable_entry   	*table_entry;
	int 							ret 			= 0;
	/*
	 * As we may need it for several parameters of the channel Table
	 * I think it is better to get the corresponding videoFormat here.
	 * Event if in some cases it will be useless
	 */
	struct videoFormatTable_entry *videoFormat_entry = NULL;

    DEBUGMSGTL(("channelTable:handler", "Processing request (%d)", reqinfo->mode));

    switch (reqinfo->mode) {

		/*
         * Read-support (also covers GetNext requests)
         */

    case MODE_GET:
        for (request=requests; request; request=request->next) {

            table_entry = (struct channelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

		switch (table_info->colnum) {
            case COLUMN_CHANNELTYPE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelType);
                break;
            case COLUMN_CHANNELUSERDESC:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->channelUserDesc,
                                          table_entry->channelUserDesc_len);
                break;
            case COLUMN_CHANNELSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelStatus);
                break;
            case COLUMN_CHANNELVIDEOFORMATINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelVideoFormatIndex);
                break;
            case COLUMN_CHANNELVIDEOFORMAT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->channelVideoFormat,
                                          table_entry->channelVideoFormat_len);
                break;
            case COLUMN_CHANNELVIDEOSAMPLING:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->channelVideoSampling,
                                          table_entry->channelVideoSampling_len);
                break;
            case COLUMN_CHANNELVIDEOBITDEPTH:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelVideoBitDepth);
                break;
            case COLUMN_CHANNELFPS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelFps);
                break;
            case COLUMN_CHANNELCOLORIMETRY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->channelColorimetry,
                                          table_entry->channelColorimetry_len);
                break;
            case COLUMN_CHANNELINTERLACED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelInterlaced);
                break;
            case COLUMN_CHANNELCOMPRESSIONFACTOR:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelCompressionFactor);
                break;
            case COLUMN_CHANNELCOMPRESSIONRATE:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelCompressionRate);
                break;
            case COLUMN_CHANNELHORZRES:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelHorzRes);
                break;
            case COLUMN_CHANNELVERTRES:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelVertRes);
                break;
            case COLUMN_CHANNELROIORIGINTOP:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelRoiOriginTop);
                break;
            case COLUMN_CHANNELROIORIGINLEFT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelRoiOriginLeft);
                break;
            case COLUMN_CHANNELROIEXTENTBOTTOM:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelRoiExtentBottom);
                break;
            case COLUMN_CHANNELROIEXTENTRIGHT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelRoiExtentRight);
                break;
            case COLUMN_CHANNELRTPPT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelRtpPt);
                break;
            case COLUMN_CHANNELRECEIVEIPADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				snmp_set_var_typed_value( request->requestvb, ASN_IPADDRESS,
                                         (u_char*) &table_entry->channelReceiveIpAddress, IPV4_SIZE );
                break;
            case COLUMN_CHANNELINTERPACKETDELAY:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelInterPacketDelay);
                break;
            case COLUMN_CHANNELSAPMESSAGEINTERVAL:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelSapMessageInterval);
                break;
            case COLUMN_CHANNELDEFAULTVIDEOFORMATINDEX:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->channelDefaultVideoFormatIndex);
                break;
            case COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
				snmp_set_var_typed_value( request->requestvb, ASN_IPADDRESS,
                                         (u_char*) &table_entry->channelDefaultReceiveIpAddress, IPV4_SIZE );
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct channelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

			if ( table_entry)
				videoFormat_entry =  videoFormatTable_getEntry( table_entry->channelVideoFormatIndex ) ;

			/* check if the index we are trying to modify is in the table, if no, return */
			if ( index_out_of_range( reginfo,
                     			   	reqinfo,
								    requests,
								 	table_info,
									channelNumber._value.int_val ) )
				return SNMP_ERR_NOERROR;

            switch (table_info->colnum) {
            case COLUMN_CHANNELUSERDESC:
				/* check this is at most a 64 byte string */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, DisplayString64);
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELSTATUS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int_range( request->requestvb, channelStart, singleFrame );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELVIDEOFORMATINDEX:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int_range( request->requestvb, 1, videoFormatNumber._value.int_val );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, SNMP_ERR_INCONSISTENTVALUE ); /* the VIVOE norm specify to return InconsistentValue error in that case */
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELCOMPRESSIONRATE:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELHORZRES:
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELVERTRES:
                ret = netsnmp_check_vb_int( request->requestvb);
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELROIORIGINTOP:
                /* or possibly 'netsnmp_check_vb_int_range' */
				/* get the corresponding videoFormatTable to get the maximum value of the top parameter */
				/* originTop + channelVertRest cannot be greater than MaxVertRes, otherwise we are outside the frame */
				if ( table_entry->channelType != serviceUser )
				{
					if ( ! videoFormat_entry ){
						netsnmp_set_request_error( reqinfo, request, SNMP_ERR_NOSUCHNAME );
						return SNMP_ERR_NOERROR;
					}
					ret = netsnmp_check_vb_int_range ( request->requestvb , 0 , videoFormat_entry->videoFormatMaxVertRes  );
				}
				else
					ret = netsnmp_check_vb_int_range ( request->requestvb , 0 , table_entry->sdp_height  );
				if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELROIORIGINLEFT:
				/* get the corresponding videoFormatTable to get the maximum value of the left parameter */
				/* originLeft+ channelHorzRest cannot be greater than MaxHorzRes, otherwise we are outside the frame */
				if ( table_entry->channelType != serviceUser ){
					if ( ! videoFormat_entry ){
						netsnmp_set_request_error( reqinfo, request, SNMP_ERR_NOSUCHNAME );
						return SNMP_ERR_NOERROR;
					}
					ret = netsnmp_check_vb_int_range ( request->requestvb , 0 , videoFormat_entry->videoFormatMaxHorzRes );
				}
				else
					ret = netsnmp_check_vb_int_range ( request->requestvb , 0 , table_entry->sdp_width);

                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELROIEXTENTBOTTOM:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELROIEXTENTRIGHT:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELRECEIVEIPADDRESS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_type( request->requestvb, ASN_IPADDRESS );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELINTERPACKETDELAY:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELSAPMESSAGEINTERVAL:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELDEFAULTVIDEOFORMATINDEX:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int_range( request->requestvb, 1, videoFormatNumber._value.int_val );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_type( request->requestvb, ASN_IPADDRESS );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
				netsnmp_set_request_error( reqinfo, request,
							SNMP_ERR_NOTWRITABLE );
					return SNMP_ERR_NOERROR;
            }
        }
        break;
	/* protect yoursefl against inconsistent (meaningless values) */
    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_entry = (struct channelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

			videoFormat_entry =  ( struct videoFormatTable_entry *) videoFormatTable_getEntry( table_entry->channelVideoFormatIndex ) ;

            switch (table_info->colnum) {
				case COLUMN_CHANNELUSERDESC:
					if ( deviceInfo.parameters[num_DeviceMode]._value.int_val	!= maintenanceMode){
						netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_RESOURCEUNAVAILABLE  );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELROIEXTENTBOTTOM:
					/* extent parameters cannot be modify if channelRoiOriginTop or channelRoiOriginLeft is not set */
					if ( table_entry->channelRoiOriginTop == 0 && table_entry->channelRoiOriginLeft == 0 ){
						netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_BADVALUE );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELROIEXTENTRIGHT:
					/* extent parameters cannot be modify if channelRoiOriginTop or channelRoiOriginLeft is not set */
					if ( table_entry->channelRoiOriginTop == 0 && table_entry->channelRoiOriginLeft == 0 ){
						netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_BADVALUE );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELINTERPACKETDELAY:
					if ( deviceInfo.parameters[num_DeviceMode]._value.int_val	!= maintenanceMode){
						netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_RESOURCEUNAVAILABLE  );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELSAPMESSAGEINTERVAL:
					if ( deviceInfo.parameters[num_DeviceMode]._value.int_val	!= maintenanceMode){
						netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_RESOURCEUNAVAILABLE  );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELDEFAULTVIDEOFORMATINDEX:
					if ( deviceInfo.parameters[num_DeviceMode]._value.int_val	!= maintenanceMode){
						netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_RESOURCEUNAVAILABLE  );
					return SNMP_ERR_NOERROR;
				}
                break;
            case COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS:
				if ( deviceInfo.parameters[num_DeviceMode]._value.int_val	!= maintenanceMode){
					netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_RESOURCEUNAVAILABLE  );
					return SNMP_ERR_NOERROR;
				}
                break;
			default:
				break; /* it might be a writable object not in maintenance group */
            }
        }
			break;

	case MODE_SET_FREE:
		break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct channelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

			videoFormat_entry =  ( struct videoFormatTable_entry *) videoFormatTable_getEntry( table_entry->channelVideoFormatIndex ) ;

			switch (table_info->colnum) {
				case COLUMN_CHANNELUSERDESC:
					table_entry->old_channelUserDesc = strdup(table_entry->channelUserDesc);
					table_entry->old_channelUserDesc_len =
						table_entry->channelUserDesc_len;
					strcpy ( table_entry->channelUserDesc,
							(char*) request->requestvb->val.string);
					table_entry->channelUserDesc_len =
						request->requestvb->val_len;
					set_desc_to_conf(table_entry->channelVideoFormatIndex,table_entry->channelUserDesc );
					break;
				case COLUMN_CHANNELSTATUS:
					table_entry->old_channelStatus 					= table_entry->channelStatus;
					table_entry->channelStatus     					= *request->requestvb->val.integer;
					channelSatus_requests_handler( table_entry );
					break;
				case COLUMN_CHANNELVIDEOFORMATINDEX:
					table_entry->old_channelVideoFormatIndex 		= table_entry->channelVideoFormatIndex;
					table_entry->channelVideoFormatIndex     		= *request->requestvb->val.integer;
					if ( ! channelTable_updateEntry(table_entry ) )
					{
					   	netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_GENERR  );
						return SNMP_ERR_NOERROR;
					}
					break;
				case COLUMN_CHANNELCOMPRESSIONRATE:
					table_entry->old_channelCompressionRate 		= table_entry->channelCompressionRate;
					table_entry->channelCompressionRate     		= *request->requestvb->val.integer;
					break;
				case COLUMN_CHANNELHORZRES:
					table_entry->old_channelHorzRes 				= table_entry->channelHorzRes;
					table_entry->channelHorzRes     				= *request->requestvb->val.integer;
					if ( table_entry->channelHorzRes != table_entry->old_channelHorzRes ) {
						if ( ! roi_requests_handler( table_entry , videoFormat_entry ) ){
							netsnmp_set_request_error(reqinfo, requests,SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELVERTRES:
					table_entry->old_channelVertRes 				= table_entry->channelVertRes;
					table_entry->channelVertRes     				= *request->requestvb->val.integer;
					if ( table_entry->channelVertRes !=  table_entry->old_channelVertRes ){
						if ( ! roi_requests_handler( table_entry , videoFormat_entry) ){
							netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELROIORIGINTOP:
					table_entry->old_channelRoiOriginTop 			= table_entry->channelRoiOriginTop;
					table_entry->channelRoiOriginTop     			= *request->requestvb->val.integer;
					if ( table_entry->channelRoiOriginTop !=  table_entry->old_channelRoiOriginTop ){
						if ( ! roi_requests_handler( table_entry , videoFormat_entry) ){
							netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELROIORIGINLEFT:
					table_entry->old_channelRoiOriginLeft 			= table_entry->channelRoiOriginLeft;
					table_entry->channelRoiOriginLeft     			= *request->requestvb->val.integer;
					if ( table_entry->channelRoiOriginLeft !=  table_entry->old_channelRoiOriginLeft ){
						if ( ! roi_requests_handler( table_entry , videoFormat_entry) ){
							netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELROIEXTENTBOTTOM:
					table_entry->old_channelRoiExtentBottom 		= table_entry->channelRoiExtentBottom;
					table_entry->channelRoiExtentBottom     		= *request->requestvb->val.integer;
					if ( table_entry->channelRoiExtentBottom !=  table_entry->old_channelRoiExtentBottom ){
						if ( ! roi_requests_handler( table_entry , videoFormat_entry) ){
							netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELROIEXTENTRIGHT:
					table_entry->old_channelRoiExtentRight 			= table_entry->channelRoiExtentRight;
					table_entry->channelRoiExtentRight    			= *request->requestvb->val.integer;
					if ( table_entry->channelRoiExtentRight !=  table_entry->old_channelRoiExtentRight ){
						if ( ! roi_requests_handler( table_entry , videoFormat_entry) ){
							netsnmp_set_request_error(reqinfo, requests , SNMP_ERR_GENERR  );
							return SNMP_ERR_NOERROR;
						}
					}
					break;
				case COLUMN_CHANNELRECEIVEIPADDRESS:
					table_entry->old_channelReceiveIpAddress 		= table_entry->channelReceiveIpAddress;
					table_entry->channelReceiveIpAddress     		= *request->requestvb->val.integer;
					break;
				case COLUMN_CHANNELINTERPACKETDELAY:
					table_entry->old_channelInterPacketDelay 		= table_entry->channelInterPacketDelay;
					table_entry->channelInterPacketDelay     		= *request->requestvb->val.integer;
					break;
				case COLUMN_CHANNELSAPMESSAGEINTERVAL:
					table_entry->old_channelSapMessageInterval 		= table_entry->channelSapMessageInterval;
					table_entry->channelSapMessageInterval     		= *request->requestvb->val.integer;
					break;
				case COLUMN_CHANNELDEFAULTVIDEOFORMATINDEX:
					table_entry->old_channelDefaultVideoFormatIndex = table_entry->channelDefaultVideoFormatIndex;
					table_entry->channelDefaultVideoFormatIndex     = *request->requestvb->val.integer;
					break;
				case COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS:
					table_entry->old_channelDefaultReceiveIpAddress = table_entry->channelDefaultReceiveIpAddress;
					table_entry->channelDefaultReceiveIpAddress     = *request->requestvb->val.integer;
					struct in_addr new_default_ip;
					new_default_ip.s_addr 							= table_entry->channelDefaultReceiveIpAddress;
					set_default_IP_from_conf(table_entry->channelIndex,  inet_ntoa(new_default_ip));
					break;
			}
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct channelTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);

			videoFormat_entry =  ( struct videoFormatTable_entry *) videoFormatTable_getEntry( table_entry->channelVideoFormatIndex ) ;

            switch (table_info->colnum) {
            case COLUMN_CHANNELUSERDESC:
                strcpy( table_entry->channelUserDesc,
                        table_entry->old_channelUserDesc);
                table_entry->channelUserDesc_len =
                        table_entry->old_channelUserDesc_len;
                break;
            case COLUMN_CHANNELSTATUS:
                table_entry->channelStatus    		 			= table_entry->old_channelStatus;
                table_entry->old_channelStatus 					= 0;
                break;
            case COLUMN_CHANNELVIDEOFORMATINDEX:
                table_entry->channelVideoFormatIndex     		= table_entry->old_channelVideoFormatIndex;
                table_entry->old_channelVideoFormatIndex 		= 0;
                break;
            case COLUMN_CHANNELCOMPRESSIONRATE:
                table_entry->channelCompressionRate     		= table_entry->old_channelCompressionRate;
                table_entry->old_channelCompressionRate 		= 0;
                break;
            case COLUMN_CHANNELHORZRES:
                table_entry->channelHorzRes     				= table_entry->old_channelHorzRes;
                table_entry->old_channelHorzRes 				= 0;
                break;
            case COLUMN_CHANNELVERTRES:
                table_entry->channelVertRes     				= table_entry->old_channelVertRes;
                table_entry->old_channelVertRes 				= 0;
                break;
            case COLUMN_CHANNELROIORIGINTOP:
                table_entry->channelRoiOriginTop     			= table_entry->old_channelRoiOriginTop;
                table_entry->old_channelRoiOriginTop 			= 0;
				/*
				 *  If we go there, then something went wrong on the ROI changes. We may want to reset the ROI parameters in
				 *  the videoFormatTable for them to be identical to the ROI parameters in channelTable
				 */
				update_videoFormat_entry_roi_from_channelTable_entry ( videoFormat_entry , table_entry );
                break;
            case COLUMN_CHANNELROIORIGINLEFT:
                table_entry->channelRoiOriginLeft     			= table_entry->old_channelRoiOriginLeft;
                table_entry->old_channelRoiOriginLeft 			= 0;
				update_videoFormat_entry_roi_from_channelTable_entry ( videoFormat_entry , table_entry );
                break;
            case COLUMN_CHANNELROIEXTENTBOTTOM:
                table_entry->channelRoiExtentBottom     		= table_entry->old_channelRoiExtentBottom;
                table_entry->old_channelRoiExtentBottom 		= 0;
				update_videoFormat_entry_roi_from_channelTable_entry ( videoFormat_entry , table_entry );
                break;
            case COLUMN_CHANNELROIEXTENTRIGHT:
                table_entry->channelRoiExtentRight     			= table_entry->old_channelRoiExtentRight;
                table_entry->old_channelRoiExtentRight 			= 0;
				update_videoFormat_entry_roi_from_channelTable_entry ( videoFormat_entry , table_entry );
                break;
            case COLUMN_CHANNELRECEIVEIPADDRESS:
                table_entry->channelReceiveIpAddress     		= table_entry->old_channelReceiveIpAddress;
                table_entry->old_channelReceiveIpAddress 		= 0;
                break;
            case COLUMN_CHANNELINTERPACKETDELAY:
                table_entry->channelInterPacketDelay     		= table_entry->old_channelInterPacketDelay;
                table_entry->old_channelInterPacketDelay 		= 0;
                break;
            case COLUMN_CHANNELSAPMESSAGEINTERVAL:
                table_entry->channelSapMessageInterval     		= table_entry->old_channelSapMessageInterval;
                table_entry->old_channelSapMessageInterval 		= 0;
                break;
            case COLUMN_CHANNELDEFAULTVIDEOFORMATINDEX:
                table_entry->channelDefaultVideoFormatIndex     = table_entry->old_channelDefaultVideoFormatIndex;
                table_entry->old_channelDefaultVideoFormatIndex = 0;
                break;
            case COLUMN_CHANNELDEFAULTRECEIVEIPADDRESS:
                table_entry->channelDefaultReceiveIpAddress     = table_entry->old_channelDefaultReceiveIpAddress;
                table_entry->old_channelDefaultReceiveIpAddress = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
