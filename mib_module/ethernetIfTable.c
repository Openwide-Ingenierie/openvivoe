/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ethernetIfTable.h"

/** Initializes the ethernetIfTable module */
void
init_ethernetIfTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ethernetIfTable();
}


/** Initialize the ethernetIfTable table by defining its contents and how it's structured */
void
initialize_table_ethernetIfTable(void)
{
    const oid ethernetIfTable_oid[] = {1,3,6,1,4,1,35990,3,1,1,12};
    const size_t ethernetIfTable_oid_len   = OID_LENGTH(ethernetIfTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_tdata                   *table_data;
    netsnmp_table_registration_info *table_info;
    netsnmp_cache                   *cache;

    DEBUGMSGTL(("ethernetIfTable:init", "initializing table ethernetIfTable\n"));

    reg = netsnmp_create_handler_registration(
              "ethernetIfTable",     ethernetIfTable_handler,
              ethernetIfTable_oid, ethernetIfTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_data = netsnmp_tdata_create_table( "ethernetIfTable", 0 );
    if (NULL == table_data) {
        snmp_log(LOG_ERR,"error creating tdata table for ethernetIfTable\n");
        return;
    }
    cache = netsnmp_cache_create(ETHERNETIFTABLE_TIMEOUT,
                                  ethernetIfTable_load, ethernetIfTable_free,
                                  ethernetIfTable_oid, ethernetIfTable_oid_len);
    if (NULL == cache) {
        snmp_log(LOG_ERR,"error creating cache for ethernetIfTable\n");
    }
    else
        cache->magic = (void *)table_data;
    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    if (NULL == table_info) {
        snmp_log(LOG_ERR,"error creating table info for ethernetIfTable\n");
        return;
    }
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: ethernetIfIndex */
                           0);

    table_info->min_column = COLUMN_ETHERNETIFSPEED;
    table_info->max_column = COLUMN_ETHERNETIFIPADDRESSCONFLICT;
    
    netsnmp_tdata_register( reg, table_data, table_info );
    if (cache) 
        netsnmp_inject_handler_before( reg, netsnmp_cache_handler_GET(cache),
                                       TABLE_TDATA_NAME);

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct ethernetIfTable_entry {
    /* Index values */
    long ethernetIfIndex;

    /* Column values */
    long ethernetIfSpeed;
    char ethernetIfMacAddress[NNN];
    size_t ethernetIfMacAddress_len;
    in_addr_t ethernetIfIpAddress;
    in_addr_t old_ethernetIfIpAddress;
    in_addr_t ethernetIfSubnetMask;
    in_addr_t old_ethernetIfSubnetMask;
    in_addr_t ethernetIfIpAddressConflict;
    in_addr_t old_ethernetIfIpAddressConflict;

    int   valid;
};

/* create a new row in the table */
netsnmp_tdata_row *
ethernetIfTable_createEntry(netsnmp_tdata *table_data
                 , long  ethernetIfIndex
                ) {
    struct ethernetIfTable_entry *entry;
    netsnmp_tdata_row *row;

    entry = SNMP_MALLOC_TYPEDEF(struct ethernetIfTable_entry);
    if (!entry)
        return NULL;

    row = netsnmp_tdata_create_row();
    if (!row) {
        SNMP_FREE(entry);
        return NULL;
    }
    row->data = entry;

    DEBUGMSGT(("ethernetIfTable:entry:create", "row 0x%x\n", (uintptr_t)row));
    entry->ethernetIfIndex = ethernetIfIndex;
    netsnmp_tdata_row_add_index( row, ASN_INTEGER,
                                 &(entry->ethernetIfIndex),
                                 sizeof(entry->ethernetIfIndex));
    if (table_data)
        netsnmp_tdata_add_row( table_data, row );
    return row;
}

/* remove a row from the table */
void
ethernetIfTable_removeEntry(netsnmp_tdata     *table_data, 
                 netsnmp_tdata_row *row) {
    struct ethernetIfTable_entry *entry;

    if (!row)
        return;    /* Nothing to remove */

    DEBUGMSGT(("ethernetIfTable:entry:remove", "row 0x%x\n", (uintptr_t)row));

    entry = (struct ethernetIfTable_entry *)row->data;
    SNMP_FREE( entry );   /* XXX - release any other internal resources */

    if (table_data)
        netsnmp_tdata_remove_and_delete_row( table_data, row );
    else
        netsnmp_tdata_delete_row( row );    
}

/* Example cache handling - set up table_data list from a suitable file */
int
ethernetIfTable_load( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *row;
    struct ethernetIfTable_entry *this;
    FILE *fp;
    char buf[STRMAX];
    long  ethernetIfIndex;

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks places where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/ethernetIfTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        /* XXX - Unpick 'buf' to extract the individual field values
                 (or at least the index values for this row) ... */
        row = ethernetIfTable_createEntry(table
                         , ethernetIfIndex
                        );
        if (row == NULL)
            continue;
        this = (struct ethernetIfTable_entry *)row->entry;
        /* XXX - ... and then populate the 'this' data structure with
                 column values (typically) extracted from 'buf' above */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
ethernetIfTable_free( netsnmp_cache *cache, void *vmagic ) {
    netsnmp_tdata     *table = (netsnmp_tdata *)vmagic;
    netsnmp_tdata_row *this;

    while ((this = netsnmp_tdata_get_first_row(table))) {
        netsnmp_tdata_remove_and_delete_row(table, this);
    }
}

/** handles requests for the ethernetIfTable table */
int
ethernetIfTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    netsnmp_tdata              *table_data;
    netsnmp_tdata_row          *table_row;
    struct ethernetIfTable_entry          *table_entry;
    int                         ret;

    DEBUGMSGTL(("ethernetIfTable:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ethernetIfTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_ETHERNETIFSPEED:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ethernetIfSpeed);
                break;
            case COLUMN_ETHERNETIFMACADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ethernetIfMacAddress,
                                          table_entry->ethernetIfMacAddress_len);
                break;
            case COLUMN_ETHERNETIFIPADDRESS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
                                            table_entry->ethernetIfIpAddress);
                break;
            case COLUMN_ETHERNETIFSUBNETMASK:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
                                            table_entry->ethernetIfSubnetMask);
                break;
            case COLUMN_ETHERNETIFIPADDRESSCONFLICT:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_IPADDRESS,
                                            table_entry->ethernetIfIpAddressConflict);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ethernetIfTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_ETHERNETIFIPADDRESS:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_ETHERNETIFSUBNETMASK:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_ETHERNETIFIPADDRESSCONFLICT:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ethernetIfTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_ETHERNETIFIPADDRESS:
                table_entry->old_ethernetIfIpAddress = table_entry->ethernetIfIpAddress;
                table_entry->ethernetIfIpAddress     = *request->requestvb->val.integer;
                break;
            case COLUMN_ETHERNETIFSUBNETMASK:
                table_entry->old_ethernetIfSubnetMask = table_entry->ethernetIfSubnetMask;
                table_entry->ethernetIfSubnetMask     = *request->requestvb->val.integer;
                break;
            case COLUMN_ETHERNETIFIPADDRESSCONFLICT:
                table_entry->old_ethernetIfIpAddressConflict = table_entry->ethernetIfIpAddressConflict;
                table_entry->ethernetIfIpAddressConflict     = *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            if (request->processed)
                continue;

            table_entry = (struct ethernetIfTable_entry *)
                              netsnmp_tdata_extract_entry(request);
            table_row   =     netsnmp_tdata_extract_row(  request);
            table_data  =     netsnmp_tdata_extract_table(request);
            table_info  =     netsnmp_extract_table_info( request);
    
            switch (table_info->colnum) {
            case COLUMN_ETHERNETIFIPADDRESS:
                table_entry->ethernetIfIpAddress     = table_entry->old_ethernetIfIpAddress;
                table_entry->old_ethernetIfIpAddress = 0;
                break;
            case COLUMN_ETHERNETIFSUBNETMASK:
                table_entry->ethernetIfSubnetMask     = table_entry->old_ethernetIfSubnetMask;
                table_entry->old_ethernetIfSubnetMask = 0;
                break;
            case COLUMN_ETHERNETIFIPADDRESSCONFLICT:
                table_entry->ethernetIfIpAddressConflict     = table_entry->old_ethernetIfIpAddressConflict;
                table_entry->old_ethernetIfIpAddressConflict = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
